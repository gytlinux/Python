# Python

### 变量
* 变量是用来存储值的所在处，变量具有名字以及数据类型两种属性。数据类型决定了内容中不同类型的值的存储结构。变量名用来调用变量。

*python是动态类型语言，不需要预先声明变量类型就可以直接使用。匾蛉的类型和值使在赋值时界定的。

#### 变量命名规则

  1.只能使用大、小写字母或者下划线(_)开头；

  2.除开头部分外，可以是大、小写字母、数字或者下划线(_)的随意组合；

  3.不能占用python关键字；

  4.变量名严格区分大小写。

#### 变量赋值(通过"="赋值)
 
  1.普通赋值

```
>>>a = 1
>>>a = 'string'
```

  2.自增赋值

```
>>>a = 1
>>>a += 1或
>>>a = a + 1
```

  3.多元赋值

```
>>>x,y,z = 1,2,3
>>>x
1
>>>y
2
>>>z
3
```

### 数据类型

* 整数类型:同数学中的整数

* 浮点数类型:同数学中的小数

* 布尔类型:只有两个值True和False。用于判断或比较数据。

* 字符串类型:引号(单、双和三引号)之间的字符集合。

### 数据结构

#### 列表
 * 列表是指一组数据有序的排列方式，可以通过下标或者切片操作来访问某一个或者某一块连续的数据。

##### 创建列表(列表定义的分界符方括号"[]")

```
列表名 = [元素1,元素2,···]
```

##### 访问元素(同于字符串切割访问)

* 索引方式:

```
列表名[索引位置]
>>>list1 = ['a','b','c']
>>>list1[1]
'b'
```

**索引值从0开始，大于0从左到右算起，小于0从右到左算起**

* 切片方式:

```
列表名[起始位置:结束位置]
>>>list1 = ['a','b','c','d']
>>>list1[1:3]
['b', 'c']
```

##### 修改元素

```
列表名[索引位置] = 值
>>>list1 = ['a','b','c']
>>>list1[1] = 'x'
>>>list1
['a', 'x', 'c']
```

##### 增加元素

* 列表类型.append(元素值):向列表尾部增加数据

```
>>>list1 = ['a','b']
>>>list1.append('c')
>>>list1
['a', 'b', 'c']
```

* 列表类型.insert(索引位置,元素值):向列表指定位置增加数据

```
>>>list1 = ['a','b','c']
>>>list1.insert(1,'hello')
>>>list1
['a', 'hello', 'b', 'c']
```

##### 增加元素

* del 列表名[索引值]:删除指定索引位置的值

```
>>>list1 = ['a','b','c']
>>>del list1[1]
>>>list1
['a', 'c']
```
* 列表类型.remove(元素值):删除列表中指定的值(只删除匹配到的第一个)

```
>>>list1 = ['a','b','c','b']
>>>list1.remove('b')
>>>list1
['a','c','b']
```

##### 删除列表

* del 列表名:删除指定的列表

```
>>>list1 = ['a','b','c']
>>>list1
['a', 'b', 'c']
>>>del list1
>>>list1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  NameError: name 'list1' is not defined

```

##### 检查列表中是否存在某个值

* 元素值 in 列表名

```
>>>list1 = ['a','b','c']
>>>'a' in list1
True
>>>'e' in list1
False
```

##### 列表合并

* 列表名1 + 列表名2

```
>>>list1 = ['a','b','c']
>>>list2 = ['d','e','f']
>>>list1 + list2
['a', 'b', 'c', 'd', 'e', 'f']
```

##### 列表乘法

* 列表名 * 重复次数

```
>>>list1 = ['a']
>>>list1 * 5
['a', 'a', 'a', 'a', 'a']
```

#### 元组

* 元组与列表相似,但元组不可变。元组比列表操作速度快，不允许修改，使数据更安全。

* 元组定义的分界符是小括号"()",如果元组只有一个元素，必须使用逗号结尾。

##### 创建元组

* 元组名 = (元素1,元素2,···)

##### 访问元素

* 索引方式:元组名[索引位置]

```
>>>tuple1 = ('a','b','c')
>>>tuple1[1]
'b'
```

* 切片方式:元组名[起始位置:结束位置]

```
>>>tuple1 = ('a','b','c')
>>>tuple1[-3:-1]
('a', 'b')
```

##### 删除元组

* del 元组名

```
>>>tuple1 = ('a','b','c')
>>>del tuple1
```

#### 列表与元组之间的转换

* 元组转换成列表:list(元组名)

```
>>>tuple1 = ('a','b','c')
>>>list(tuple1)
['a', 'b', 'c']

```

* 列表转换成元组:tuple(列表名)

```
>>>list1 = ['a','b','c']
>>>tuple(list1)
('a', 'b', 'c')
```

#### 字典

* 列表的索引只能是数字，如果想改变索引的类型只能使用字典

* 字典的每个元素是键值对；键是唯一的值；值没有特定的顺序


##### 创建字典

* 字典名 = {键1: 值1, 键2: 值2,···}

* 键值之间使用冒号分割":";多个键值之间使用逗号分隔;字典定义的分界符是大括号"{}"

##### 访问元素

* 字典名[键]
* 字典名.get(键)

```
>>>dict1 = {'qq':'123456789','weixin':'987654321'}
>>>dict1['qq']
'123456789'
>>>dict1.get('weixin')
'987654321'
```

**如果字典中访问的键不存在中括号方式访问会报错，get方式访问不会报错**

##### 添加元素

* 字典名['键'] = 值

```
>>>dict1 = {'qq':'123456'}
>>>dict1['weixin'] = '654321'
>>>dict1
{'qq': '123456', 'weixin': '654321'}
```

##### 修改元素

* 字典名['键'] = 值

```
>>>dict1 = {'qq':'123456','weixin':'654321'}
>>>dict1['qq'] = '123456789'
>>>dict1
{'qq': '123456789', 'weixin': '654321'}
```
**修改元素与添加元素的语法是一样的，意味着如果”键“存在就覆盖，不存在就新建**

##### 删除元素

* del 字典名[键]

```
>>>dict1 = {'qq':'123456','weixin':'654321'}
>>>del dict1['qq']
{'weixin': '654321'}
```

##### 删除字典

* del 字典名

```
>>>dict1 = {'qq':'123456'}
>>>del dict1 
```

##### 字典常用方法

* 字典类型.has_key(键):查询字典中是否存在指定的键

```
>>>dict1 = {'qq':'123','weixin':'456'}
>>>dict1.has_key(qq)
True
>>>dict1.has_key(weibo)
False
```

* 字典类型.get(键):获取指定的键对应的值，如果存在就返回

```
>>>dict1 = {'qq':'123','weixin':'456'}
>>>dict1.get('weixin')
'456'
>>>dict1.get('weibo')
>>>
```

### 分支结构

#### if语句

##### 执行逻辑

```
语句0
if 逻辑表达式:
    语句1
    语句2
语句3
```

* 执行语句0

* 逻辑表达式结果为True执行语句1、语句2;结果为False不执行语句1、语句2.

* 执行语句3

##### if..else..语句

```
语句 0
if 逻辑表达式\条件:
    语句块1
else:
    语句块2
语句 3
```

* 执行code 0；

* 逻辑表达式为True，执行语句块1;为False，执行语句块2；

* 执行语句3.

##### if...elif..语句

```
语句0
if 逻辑表达式1:
    语句块1
elif 逻辑表达式2:
    语句块2
...
语句3
```

* 执行语句0

* 逻辑表达式1结果为True，执行语句1并结束，为False执行逻辑表达式2；

* 逻辑表达式2同上；

* 执行语句3

### 循环

* 循环是程序设局语言中反复执行某些代码的一种计算机处理过程，是一组相同或相似语句被有规律的重复执行。

#### while 循环

##### 执行逻辑

```
while 逻辑表达式:
    语句块
```

* 计算逻辑表达式的值；

* 值为True就执行语句块，之后继续判断逻辑表达式的值;

* 直到逻辑表达式的值为False时结束循环。

#### for循环

##### 执行逻辑

```
for 变量 in 列表生成器(变量取值范围):
    语句块
```

* 变量从列表生成器中取值；

* 每次变量获取一个值就执行一次语句块，之后继续获取下一个值；

* 直到变量将列表生成器中的值全部获取过时结束循环

#### 循环控制

* break : 终止当前循环

* continue : 跳过当前一轮循环进行下一次循环

### 函数

* 通过函数名可重复调用的代码块；函数必须先定义，后调用。

#### 无参函数

##### 定义无参函数

```
def 函数名称():
    代码块
    [return [表达式]]
```

* return语句用于退出函数调用；如果return后有表达式，则返回表达式的值；如果没有表达式，寄返回None；如果return语句不存在，返回None

##### 调用无参函数

* [变量] = 函数名称()

#### 有参函数

```
def 函数名称(参数列表):
    代码块
    [return [表达式]]

```

* 参数列表中的参数只是占位符，体现参数的个数，又成为形参，真正传递进去的值成为实参，参数列表中可以指定参数的默认值。

##### 位置参数

```
>>>def add(x,y):
        return x + y 

>>>add(1,2)
3
```

##### 关键字参数

```
>>>def add(x,y):
       return x + y

>>>add(y=3,x=1)
4
```

##### 调用有参函数

* [变量] = 函数名称(参数列表)

* 参数列表可以使用位置传参，也可以使用关键字传参，位置参数必须出现在默认参数之前。

#### 变量作用域

* 作用域是指变量在程序中的有效范围，变量声明的位置决定它的作用域。

##### 全局变量

* global 全局变量

* 在一个模块中最高级别的变量是全局作用域，除非被删除，否则存货到程序运行结束所有的函数都能访问全局变量。

##### 局部变量

* 定义在函数内的变量有局部作用域，依赖于定义变量的函数现阶段是否处于活动状态，调用函数时，局部变量产生，暂时存在，函数执行完毕，局部变量被释放。

**同一个函数中不允许有同名的局部变量;在不同函数中，可以有同名局部变量，在同一个程序中，全局变量和局部变量同名时，局部变量具有更高的有限级(就近原则)**


### 模块

* 模块就是包含python定义和语句的文件。模块之间代码共享，可以相互调用，实现代码重用

#### 导入模块

* 一行导入一个模块: import 模块名

* 一行导入多个模块: import 模块1[,模块2[,...,模块名n]]

* 如果模块在顶层导入，则作用于时全局的，在函数中导入，作用域时局部的，建议把所有的模块在顶层导入。

#### 导入模块的指定方法

* 一行导入一个模块: from 模块名 import 方法名

* 一行导入多个模块: from 模块名 import 方法名1[,方法名2[,...,方法名n]]

* 绝不推荐使用from模块名import* 的方式导入方法。

#### 给模块或模块的方法进行重命名

```
import 模块名 as 模块新名称
from 模块名 import 方法名 as 新方法名

```

### 异常处理

#### 认识异常

* 在程序的运行过程中所发生的不正常事件，会中断正在运行的程序。对引发的异常进行处理，保证程序能继续执行并获得正确的结果。

| 异常类 | 说明 |
| ------ | ---- |
| NameError | 尝试访问一个未声明的变量 |
| ZeroDivisionError | 除数为零 |
| SyntaxError | 解释器语法错误 |
| IndexError | 请求的缩影超出序列范围 |
| KeyError | 请求一个不存在的字典关键字 |
| IOError | 输入/输出错误 |
| AttributeError | 尝试访问位置的对象属性 |

#### 异常处理

* 异常处理通过try语句检测异常，任何在try语句块里的代码都会被检测，检查是否有异常发生。

##### try-except

* 定义异常监控的一段代码，并且提供处理异常的机制

```
try:
   语句 #被监控的异常代码
except 异常类[,对象]:
   语句 #异常处理的代码
```

* 执行try语句块中的语句;

* 如果出现异常，立即中断try语句块的执行，转到except语句块;

* 将异常类型与except语句块中的异常匹配。如果批评日成功，执行相应的异常处理，如果匹配不成功，将异常传递给更高一级的try语句

* 如果异常一直没有找到处理程序则停止执行，抛出异常信息。

##### try-except-else

* try语句块中没有检测到异常，执行else语句块

```
try:
    语句 #被监控异常的代码
except 异常类[,对象]:
    语句 #异常处理的代码
else:
    语句 #try语句块的代码全部成功时的操作

```

##### try-except-...

* 一个try语句块可以对应多个except语句块

```
try:
    语句  #被监控异常的代码
except 异常类1[,对象]:
    语句  #异常处理的代码
except 异常类2[,对象]:
    语句  #异常处理的代码
```

* 一个except语句块里可以处理多个异常，处理多个异常时，要求异常防止在一个元组里

```
try:
    语句 #被监控异常的代码
except (异常类1[,异常类2[,...,异常类n]])[,对象]:
    语句 # 异常处理的代码
    
```

##### try-finally

* 无论发生什么，都会执行的一段代码。可以与try语句块一起使用。

* try-except-finally

* try-except-else-finally

* try-finally

* 通常用来释放被占用的资源

```
try:
    语句  #被监控异常的代码
except 异常类[,对象]:
    语句  #异常处理的代码
[else:
    语句] #try语句块的代码全部成功时的操作
finally:
    语句  #无论如何都执行
```

#### 抛出异常

* 除了系统自动抛出异常外，在编程过程中，有些问题是系统无法发现并解决的。通过抛出异常、接受并处理异常，实现程序的多分支处理。

```
raise 异常类
raise 异常类(参数或元组)
```


